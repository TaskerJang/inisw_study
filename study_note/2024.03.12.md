## 1. robotparser

## 2. urllib

## 3. quote, unquote, quote_plus, urlparse

## 4. scheme, netloc, path, params, query, fragment

## 5. parse_qs, parse_qsl

## 6. urlencode

## 7. urljoin

## 8. user-agent

## 9. Request()

## 10. status, reason,getheaders

## 11. decode('utf8')

## 12. try except 구문

## 13. lazy evaluation => 메모리에서 실행 (빠르다.) > 용량이 커지면 가상 메모리 사용 > 이후 더 커지면 에러

## 14. iter() => iterator가 된다. => __iter__ (iterable이다.) => next()로 값을 차례대로 (중간 X) 추출한다. => 나머지 값들은 메모리 상으로 올라간다.
    => 없으면 stopiteration 에러 발생
## 15. `__next__` => lazy technic 사용 가능

## 16. __next__가 있으면 iterable로 사용 가능 하다는 뜻이다.

## 17. unifying types and classes => 데이터 타입이 곧 클래스다.

## 18. dynamic typing

## 19. 메타클래스의 입장에서 클래스는 인스턴스다.

## 20. tuple => tuple() => () => ,,, => 단축 표현

## 21. 함수도 데이터 타입이다. => type (함수명)=> function

## 22. type(클래스) => type : 메타 클래스

## 23. 클래스와 인스턴스를 구분하는 방법은 type()을 쳐보는 것이다. 

## 24. type(인스턴스) => `__main__` => 현재 글로벌 공간에서 만든것. (import 하지 않고)

## 25. 함수에 대응하는 magic/special/dundu (duble underbar) 존재 => 메서드가 있으면 함수가 있다. but 역은 성립하지 않는다.

## 26. `__class__` : pythonic 

## 27. vars = `__dict__`

## 28. vars(클래스명) => 

## 29. getrefcount => garbagecollection => 메모리 정리

## 30. `__weakref__` vs `__strongref__`

## 31. bound method => 함수 기반 메서드

## 32. 상속 => 남이 만든 것을 가져다가 나에게 맞춘다.

## 33. class 클래스명 (object)  => 오브젝트로부터 상속을 받는다. default 라서 생략이 가능하다.

## 34. 단일 상속 vs 다중 상속 : 다중 상속에서는 다이아몬드 문제가 발생.

## 35. 인스턴스 변수가 없으면 클래스 변수에 찾아간다. 클래스 변수가 없으면 부모에게 찾아간다. => delegate (위임하다.)

## 36. MRO => method resolution order => 상속 체계가 어긋나면 MRO ERROR가 발생.

## 37. mro () => 상속 순서

## 38. 오버라이딩 : 상속 후 수정 - delegate vs 오버로딩 - 부모의 기능을 일부 사용

## 39. super(자기클래스명, self) = super() => 부모 것을 가져오는 키워드. => 다중 상속 체계를 모두 고려. 중복없이!! => mro 거꾸로!!

## 40. abc -> abstract base class => 추상화 기반 클래스

## 41. subscriptable => indexing 이 불가능 할때 발생하는 에러

## 42. 상속없이 sequence type을 만들 수 있다.